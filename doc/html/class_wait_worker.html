<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Spexpert: WaitWorker Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Spexpert
   </div>
   <div id="projectbrief">Batch experiments controlling on Spex.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_wait_worker.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-slots">Private Slots</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">WaitWorker Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is intended for the internal use in the <a class="el" href="class_wait_task_list.html" title="This class provides interface for executing tasks which waits for some process to be finished...">WaitTaskList</a> for controlling if the processes controlled by <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> objects is running. It is executed in new thread.  
 <a href="class_wait_worker.html#details">More...</a></p>

<p>Inherits QObject.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr class="memitem:af01864effa7662c8261128ff12fb922d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af01864effa7662c8261128ff12fb922d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#af01864effa7662c8261128ff12fb922d">stop</a> ()</td></tr>
<tr class="memdesc:af01864effa7662c8261128ff12fb922d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the <a class="el" href="class_wait_worker.html#a434d284c0e08697979b5c8c1a53fd529" title="This method controlls all the WaitTask objects from the internal list, wheather thei are running...">waitWorkerLoop()</a> execution by calling the <a class="el" href="class_wait_worker.html#a52b9f53cccaa737e7de6d978c96ff9ab" title="This method is invoked by the stop() method to WaitTask::stop() all the contained WaitTask objects an...">quitLoop()</a> method. <br /></td></tr>
<tr class="separator:af01864effa7662c8261128ff12fb922d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaff9ea88795fa9d902711c1952828cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#adaff9ea88795fa9d902711c1952828cd">addWaitTask</a> (const <a class="el" href="struct_wait_task_list_traits_1_1_task_item.html">WaitTaskListTraits::TaskItem</a> &amp;wt)</td></tr>
<tr class="memdesc:adaff9ea88795fa9d902711c1952828cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> in the internal list. It controlls if the <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> does not have some <a class="el" href="class_wait_task.html#a3984ae37eae1a984db2f2417df2bfbbf" title="Returns initial delay. See the class description for more details. ">WaitTask::initialDelay()</a>. See description of <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> for more details.  <a href="#adaff9ea88795fa9d902711c1952828cd">More...</a><br /></td></tr>
<tr class="separator:adaff9ea88795fa9d902711c1952828cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:a5f65bc5e4691e9542afef8df55bf27be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f65bc5e4691e9542afef8df55bf27be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#a5f65bc5e4691e9542afef8df55bf27be">quitFinished</a> ()</td></tr>
<tr class="memdesc:a5f65bc5e4691e9542afef8df55bf27be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signal is emited only from the <a class="el" href="class_wait_worker.html#a52b9f53cccaa737e7de6d978c96ff9ab" title="This method is invoked by the stop() method to WaitTask::stop() all the contained WaitTask objects an...">quitLoop()</a> method. <br /></td></tr>
<tr class="separator:a5f65bc5e4691e9542afef8df55bf27be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab775487e06899dc74d8992c996606f8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#ab775487e06899dc74d8992c996606f8f">WaitWorker</a> (QObject *parent=0)</td></tr>
<tr class="memdesc:ab775487e06899dc74d8992c996606f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construts the <a class="el" href="class_wait_worker.html" title="This class is intended for the internal use in the WaitTaskList for controlling if the processes cont...">WaitWorker</a> object.  <a href="#ab775487e06899dc74d8992c996606f8f">More...</a><br /></td></tr>
<tr class="separator:ab775487e06899dc74d8992c996606f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767f19b8b71eff239a9481ede483dee4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a767f19b8b71eff239a9481ede483dee4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#a767f19b8b71eff239a9481ede483dee4">~WaitWorker</a> ()</td></tr>
<tr class="memdesc:a767f19b8b71eff239a9481ede483dee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys <a class="el" href="class_wait_worker.html" title="This class is intended for the internal use in the WaitTaskList for controlling if the processes cont...">WaitWorker</a>. <br /></td></tr>
<tr class="separator:a767f19b8b71eff239a9481ede483dee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-slots"></a>
Private Slots</h2></td></tr>
<tr class="memitem:a71dec4dbc5a123f20d0a5a7f707ed5a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#a71dec4dbc5a123f20d0a5a7f707ed5a3">addDelayedWaitTask</a> (const <a class="el" href="struct_wait_task_list_traits_1_1_task_item.html">WaitTaskListTraits::TaskItem</a> &amp;wt)</td></tr>
<tr class="memdesc:a71dec4dbc5a123f20d0a5a7f707ed5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called from the <a class="el" href="class_wait_worker.html#adaff9ea88795fa9d902711c1952828cd" title="Adds WaitTask in the internal list. It controlls if the WaitTask does not have some WaitTask::initial...">addWaitTask()</a> method after the <a class="el" href="class_wait_task.html#a3984ae37eae1a984db2f2417df2bfbbf" title="Returns initial delay. See the class description for more details. ">WaitTask::initialDelay()</a> delay elapses and adds the <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> in the internal list and invokes its <a class="el" href="class_wait_task.html#ab20934c4c6723db758564eef74eec5c4" title="Contains commands which is executed at the beginning of the waiting. ">WaitTask::start()</a> method.  <a href="#a71dec4dbc5a123f20d0a5a7f707ed5a3">More...</a><br /></td></tr>
<tr class="separator:a71dec4dbc5a123f20d0a5a7f707ed5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434d284c0e08697979b5c8c1a53fd529"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a434d284c0e08697979b5c8c1a53fd529"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#a434d284c0e08697979b5c8c1a53fd529">waitWorkerLoop</a> ()</td></tr>
<tr class="memdesc:a434d284c0e08697979b5c8c1a53fd529"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method controlls all the <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> objects from the internal list, wheather thei are running. If not, it executes their <a class="el" href="class_wait_task.html#a5f3a89b190e0ef7443cc3b9cc8857e9a" title="Contains commands which is executed when the waiting is finished and emits waitTaskFinished() signal...">WaitTask::finish()</a> method and removes them from the internal list. <br /></td></tr>
<tr class="separator:a434d284c0e08697979b5c8c1a53fd529"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a52b9f53cccaa737e7de6d978c96ff9ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52b9f53cccaa737e7de6d978c96ff9ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#a52b9f53cccaa737e7de6d978c96ff9ab">quitLoop</a> ()</td></tr>
<tr class="memdesc:a52b9f53cccaa737e7de6d978c96ff9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is invoked by the <a class="el" href="class_wait_worker.html#af01864effa7662c8261128ff12fb922d" title="Stops the waitWorkerLoop() execution by calling the quitLoop() method. ">stop()</a> method to <a class="el" href="class_wait_task.html#a6bbc82bd62e9fc2cad789a24a6ab928a" title="Contains commands which is executed when the waiting is stopped. It emits waitingFailed() signal and ...">WaitTask::stop()</a> all the contained <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> objects and to clear the list of the all contained <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> objeccts. At the end, it emits <a class="el" href="class_wait_worker.html#a5f65bc5e4691e9542afef8df55bf27be" title="This signal is emited only from the quitLoop() method. ">quitFinished()</a> signal. <br /></td></tr>
<tr class="separator:a52b9f53cccaa737e7de6d978c96ff9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a87df3552b89aad0db75385398426a9c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87df3552b89aad0db75385398426a9c9"></a>
QTimer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#a87df3552b89aad0db75385398426a9c9">timer</a></td></tr>
<tr class="memdesc:a87df3552b89aad0db75385398426a9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal timer, the QTimer::timeout() method of which is connected to the <a class="el" href="class_wait_worker.html#a434d284c0e08697979b5c8c1a53fd529" title="This method controlls all the WaitTask objects from the internal list, wheather thei are running...">waitWorkerLoop()</a> slot and its repetition rate is set to the <a class="el" href="class_wait_worker.html#a088f21300ece1749e1e7e02a130275df" title="The repetition rate in ms of WaitWorker::timer, which determines how often the contained WaitTask obj...">WaitWorker::refreshRate_</a> ms. <br /></td></tr>
<tr class="separator:a87df3552b89aad0db75385398426a9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcda880e64348cdd84e2ebbb9926447"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fcda880e64348cdd84e2ebbb9926447"></a>
QMap&lt; unsigned int, <a class="el" href="struct_wait_task_list_traits_1_1_task_item.html">WaitTaskListTraits::TaskItem</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#a7fcda880e64348cdd84e2ebbb9926447">waitTasks_</a></td></tr>
<tr class="memdesc:a7fcda880e64348cdd84e2ebbb9926447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal list of all contained <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> objects. <br /></td></tr>
<tr class="separator:a7fcda880e64348cdd84e2ebbb9926447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa716c2d16efa5df8492f21f11f3a2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affa716c2d16efa5df8492f21f11f3a2d"></a>
QList&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#affa716c2d16efa5df8492f21f11f3a2d">markedForDelete</a></td></tr>
<tr class="memdesc:affa716c2d16efa5df8492f21f11f3a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable enables using the iterators for deleting objects from QMap class, because QMap do not preserves iterator positions after any modification. This variable is used only in the waitWorkerLoop, but because the loop is rapidly recurently invoked it is created globaly to save computer resources. <br /></td></tr>
<tr class="separator:affa716c2d16efa5df8492f21f11f3a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088f21300ece1749e1e7e02a130275df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a088f21300ece1749e1e7e02a130275df"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wait_worker.html#a088f21300ece1749e1e7e02a130275df">refreshRate_</a></td></tr>
<tr class="memdesc:a088f21300ece1749e1e7e02a130275df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The repetition rate in ms of <a class="el" href="class_wait_worker.html#a87df3552b89aad0db75385398426a9c9" title="Internal timer, the QTimer::timeout() method of which is connected to the waitWorkerLoop() slot and i...">WaitWorker::timer</a>, which determines how often the contained <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> objects are controlled, if they are <a class="el" href="class_wait_task.html#a39f09592449c61469d093f980a23cbfd" title="Virtual method, which need to be reimplemented. If this method returns false, the waiting in WaitTask...">WaitTask::running()</a> <br /></td></tr>
<tr class="separator:a088f21300ece1749e1e7e02a130275df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is intended for the internal use in the <a class="el" href="class_wait_task_list.html" title="This class provides interface for executing tasks which waits for some process to be finished...">WaitTaskList</a> for controlling if the processes controlled by <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> objects is running. It is executed in new thread. </p>
<p>When the new <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> is added to the list of controlled tasks by the <a class="el" href="class_wait_worker.html#adaff9ea88795fa9d902711c1952828cd" title="Adds WaitTask in the internal list. It controlls if the WaitTask does not have some WaitTask::initial...">addWaitTask()</a> method, it is checked if the task has some <a class="el" href="class_wait_task.html#a3984ae37eae1a984db2f2417df2bfbbf" title="Returns initial delay. See the class description for more details. ">WaitTask::initialDelay()</a>. If yes, the new <a class="el" href="class_delayed_start.html" title="This class is helper class, which wraps the WaitTask object if it has some WaitTask::initialDelay() i...">DelayedStart</a> object is created and the task is inserted inside it. The <a class="el" href="class_delayed_start.html#ab12e84ab2900082373f556051f260c9c" title="This signal is emited from the delayedAddWaitTask() method and connected to the WaitWorker::addDelaye...">DelayedStart::addTask()</a> signal is connected to the <a class="el" href="class_wait_worker.html#a71dec4dbc5a123f20d0a5a7f707ed5a3" title="This method is called from the addWaitTask() method after the WaitTask::initialDelay() delay elapses ...">addDelayedWaitTask()</a> method and then the QTimer::singleShot() method is connected to the <a class="el" href="class_delayed_start.html#a579d849a61a9f20cb29bc18d5be7611a" title="This slot is invoked by the QTimer from the WaitWorker::addWaitTask() method. It emits addTask() sign...">DelayedStart::delayedAddWaitTask()</a> slot, which emits <a class="el" href="class_delayed_start.html#ab12e84ab2900082373f556051f260c9c" title="This signal is emited from the delayedAddWaitTask() method and connected to the WaitWorker::addDelaye...">DelayedStart::addTask()</a> signal connected to <a class="el" href="class_wait_worker.html#a71dec4dbc5a123f20d0a5a7f707ed5a3" title="This method is called from the addWaitTask() method after the WaitTask::initialDelay() delay elapses ...">addDelayedWaitTask()</a> slot. If there is no <a class="el" href="class_wait_task.html#a3984ae37eae1a984db2f2417df2bfbbf" title="Returns initial delay. See the class description for more details. ">WaitTask::initialDelay()</a>, the <a class="el" href="class_wait_worker.html#a71dec4dbc5a123f20d0a5a7f707ed5a3" title="This method is called from the addWaitTask() method after the WaitTask::initialDelay() delay elapses ...">addDelayedWaitTask()</a> slot is invoked directly from this method.</p>
<p><a class="el" href="class_wait_worker.html#a71dec4dbc5a123f20d0a5a7f707ed5a3" title="This method is called from the addWaitTask() method after the WaitTask::initialDelay() delay elapses ...">addDelayedWaitTask()</a> controlls if any <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> is already beeing checked. If no, the internal QTimer is started with repetition rate of <a class="el" href="class_wait_worker.html#a088f21300ece1749e1e7e02a130275df" title="The repetition rate in ms of WaitWorker::timer, which determines how often the contained WaitTask obj...">WaitWorker::refreshRate_</a> ms, the signal QTimer::timeout() of which is connected to the <a class="el" href="class_wait_worker.html#a434d284c0e08697979b5c8c1a53fd529" title="This method controlls all the WaitTask objects from the internal list, wheather thei are running...">waitWorkerLoop()</a> slot, and the <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> is inserted into the interanl list and its <a class="el" href="class_wait_task.html#ab20934c4c6723db758564eef74eec5c4" title="Contains commands which is executed at the beginning of the waiting. ">WaitTask::start()</a> is invoked.</p>
<p>In the <a class="el" href="class_wait_worker.html#a434d284c0e08697979b5c8c1a53fd529" title="This method controlls all the WaitTask objects from the internal list, wheather thei are running...">waitWorkerLoop()</a>, all <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> objects from the list is tested, if their <a class="el" href="class_wait_task.html#a39f09592449c61469d093f980a23cbfd" title="Virtual method, which need to be reimplemented. If this method returns false, the waiting in WaitTask...">WaitTask::running()</a> are true and the <a class="el" href="class_wait_task.html#a5f3a89b190e0ef7443cc3b9cc8857e9a" title="Contains commands which is executed when the waiting is finished and emits waitTaskFinished() signal...">WaitTask::finish()</a> method is invoked for those which have already finished. The finished <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> objects are also removed from the internal list. If there is no <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> in the list, the internal QTimer is stopped.</p>
<p>The <a class="el" href="class_wait_worker.html#a434d284c0e08697979b5c8c1a53fd529" title="This method controlls all the WaitTask objects from the internal list, wheather thei are running...">waitWorkerLoop()</a> execution can be stopped by invoking the stop method, which calls the <a class="el" href="class_wait_worker.html#a52b9f53cccaa737e7de6d978c96ff9ab" title="This method is invoked by the stop() method to WaitTask::stop() all the contained WaitTask objects an...">quitLoop()</a> method, which stops all the running task by the <a class="el" href="class_wait_task.html#a6bbc82bd62e9fc2cad789a24a6ab928a" title="Contains commands which is executed when the waiting is stopped. It emits waitingFailed() signal and ...">WaitTask::stop()</a> method executin and then it removes all the added <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> objects from the internal list. At the end, it stops the internal QTimer and emits <a class="el" href="class_wait_worker.html#a5f65bc5e4691e9542afef8df55bf27be" title="This signal is emited only from the quitLoop() method. ">quitFinished()</a> signal, which is connected to the <a class="el" href="class_wait_task_list.html#acb4be74c64bd3df403657f625384f453" title="This method is invoked only when the thread was quited by calling waitWorker&#39;s WaitWorker::stop() met...">WaitTaskList::onWorkerQuitFinished()</a> slot. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab775487e06899dc74d8992c996606f8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WaitWorker::WaitWorker </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construts the <a class="el" href="class_wait_worker.html" title="This class is intended for the internal use in the WaitTaskList for controlling if the processes cont...">WaitWorker</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent QObject in the Qt's ownership system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adaff9ea88795fa9d902711c1952828cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaitWorker::addWaitTask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_wait_task_list_traits_1_1_task_item.html">WaitTaskListTraits::TaskItem</a> &amp;&#160;</td>
          <td class="paramname"><em>wt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> in the internal list. It controlls if the <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> does not have some <a class="el" href="class_wait_task.html#a3984ae37eae1a984db2f2417df2bfbbf" title="Returns initial delay. See the class description for more details. ">WaitTask::initialDelay()</a>. See description of <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> for more details. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_wait_worker.html#a71dec4dbc5a123f20d0a5a7f707ed5a3" title="This method is called from the addWaitTask() method after the WaitTask::initialDelay() delay elapses ...">addDelayedWaitTask</a>, <a class="el" href="class_delayed_start.html" title="This class is helper class, which wraps the WaitTask object if it has some WaitTask::initialDelay() i...">DelayedStart</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a71dec4dbc5a123f20d0a5a7f707ed5a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaitWorker::addDelayedWaitTask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_wait_task_list_traits_1_1_task_item.html">WaitTaskListTraits::TaskItem</a> &amp;&#160;</td>
          <td class="paramname"><em>wt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called from the <a class="el" href="class_wait_worker.html#adaff9ea88795fa9d902711c1952828cd" title="Adds WaitTask in the internal list. It controlls if the WaitTask does not have some WaitTask::initial...">addWaitTask()</a> method after the <a class="el" href="class_wait_task.html#a3984ae37eae1a984db2f2417df2bfbbf" title="Returns initial delay. See the class description for more details. ">WaitTask::initialDelay()</a> delay elapses and adds the <a class="el" href="class_wait_task.html" title="Abstract class which forms the base for task usable with WaitTaskList. The running() method need to b...">WaitTask</a> in the internal list and invokes its <a class="el" href="class_wait_task.html#ab20934c4c6723db758564eef74eec5c4" title="Contains commands which is executed at the beginning of the waiting. ">WaitTask::start()</a> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wt</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="waittasklist_8h_source.html">waittasklist.h</a></li>
<li>waittasklist.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_wait_worker.html">WaitWorker</a></li>
    <li class="footer">Generated on Fri May 15 2015 08:16:00 for Spexpert by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
